//
//SPDX-License-Identifier: MIT
//
//Copyright (c) 2022, SCANOSS
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in
//all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//THE SOFTWARE.

//**
// License definition details
//*

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.31.1
// source: scanoss/api/licenses/v2/scanoss-licenses.proto

package licensesv2

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	commonv2 "github.com/scanoss/papi/api/commonv2"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Type int32

const (
	Type_UNKNOWN       Type = 0
	Type_PERMISSIVE    Type = 1
	Type_COPYLEFT      Type = 2
	Type_COMMERCIAL    Type = 3
	Type_PROPRIETARY   Type = 4
	Type_PUBLIC_DOMAIN Type = 5
)

// Enum value maps for Type.
var (
	Type_name = map[int32]string{
		0: "UNKNOWN",
		1: "PERMISSIVE",
		2: "COPYLEFT",
		3: "COMMERCIAL",
		4: "PROPRIETARY",
		5: "PUBLIC_DOMAIN",
	}
	Type_value = map[string]int32{
		"UNKNOWN":       0,
		"PERMISSIVE":    1,
		"COPYLEFT":      2,
		"COMMERCIAL":    3,
		"PROPRIETARY":   4,
		"PUBLIC_DOMAIN": 5,
	}
)

func (x Type) Enum() *Type {
	p := new(Type)
	*p = x
	return p
}

func (x Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Type) Descriptor() protoreflect.EnumDescriptor {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_enumTypes[0].Descriptor()
}

func (Type) Type() protoreflect.EnumType {
	return &file_scanoss_api_licenses_v2_scanoss_licenses_proto_enumTypes[0]
}

func (x Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Type.Descriptor instead.
func (Type) EnumDescriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{0}
}

// SPDX cross-reference with validation metadata.
type SPDX_CrossRef struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Url           string                 `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	IsValid       bool                   `protobuf:"varint,2,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
	IsLive        bool                   `protobuf:"varint,3,opt,name=is_live,json=isLive,proto3" json:"is_live,omitempty"`
	Timestamp     string                 `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	IsWaybackLink bool                   `protobuf:"varint,5,opt,name=is_wayback_link,json=isWaybackLink,proto3" json:"is_wayback_link,omitempty"`
	Order         int32                  `protobuf:"varint,6,opt,name=order,proto3" json:"order,omitempty"`
	Match         string                 `protobuf:"bytes,7,opt,name=match,proto3" json:"match,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SPDX_CrossRef) Reset() {
	*x = SPDX_CrossRef{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SPDX_CrossRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SPDX_CrossRef) ProtoMessage() {}

func (x *SPDX_CrossRef) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SPDX_CrossRef.ProtoReflect.Descriptor instead.
func (*SPDX_CrossRef) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{0}
}

func (x *SPDX_CrossRef) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *SPDX_CrossRef) GetIsValid() bool {
	if x != nil {
		return x.IsValid
	}
	return false
}

func (x *SPDX_CrossRef) GetIsLive() bool {
	if x != nil {
		return x.IsLive
	}
	return false
}

func (x *SPDX_CrossRef) GetTimestamp() string {
	if x != nil {
		return x.Timestamp
	}
	return ""
}

func (x *SPDX_CrossRef) GetIsWaybackLink() bool {
	if x != nil {
		return x.IsWaybackLink
	}
	return false
}

func (x *SPDX_CrossRef) GetOrder() int32 {
	if x != nil {
		return x.Order
	}
	return 0
}

func (x *SPDX_CrossRef) GetMatch() string {
	if x != nil {
		return x.Match
	}
	return ""
}

// SPDX license exception details.
type SPDX_Exception struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                          // "Classpath-exception-2.0"
	FullName      string                 `protobuf:"bytes,2,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`              // "Classpath exception 2.0"
	DetailsUrl    string                 `protobuf:"bytes,3,opt,name=details_url,json=detailsUrl,proto3" json:"details_url,omitempty"`        // SPDX exception JSON URL
	SeeAlso       []string               `protobuf:"bytes,5,rep,name=see_also,json=seeAlso,proto3" json:"see_also,omitempty"`                 // Reference URLs
	IsDeprecated  bool                   `protobuf:"varint,6,opt,name=is_deprecated,json=isDeprecated,proto3" json:"is_deprecated,omitempty"` // Exception is deprecated
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SPDX_Exception) Reset() {
	*x = SPDX_Exception{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SPDX_Exception) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SPDX_Exception) ProtoMessage() {}

func (x *SPDX_Exception) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SPDX_Exception.ProtoReflect.Descriptor instead.
func (*SPDX_Exception) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{1}
}

func (x *SPDX_Exception) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *SPDX_Exception) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *SPDX_Exception) GetDetailsUrl() string {
	if x != nil {
		return x.DetailsUrl
	}
	return ""
}

func (x *SPDX_Exception) GetSeeAlso() []string {
	if x != nil {
		return x.SeeAlso
	}
	return nil
}

func (x *SPDX_Exception) GetIsDeprecated() bool {
	if x != nil {
		return x.IsDeprecated
	}
	return false
}

// SPDX license registry metadata.
type SPDX struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                          // "GPL-2.0-only", "MIT" - the SPDX license identifier
	FullName      string                 `protobuf:"bytes,2,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`              // Official SPDX registry name (empty if license not in SPDX registry)
	DetailsUrl    string                 `protobuf:"bytes,4,opt,name=details_url,json=detailsUrl,proto3" json:"details_url,omitempty"`        // JSON API URL for full details
	ReferenceUrl  string                 `protobuf:"bytes,5,opt,name=reference_url,json=referenceUrl,proto3" json:"reference_url,omitempty"`  // HTML page URL
	IsDeprecated  bool                   `protobuf:"varint,6,opt,name=is_deprecated,json=isDeprecated,proto3" json:"is_deprecated,omitempty"` // License is deprecated
	IsFsfLibre    bool                   `protobuf:"varint,7,opt,name=is_fsf_libre,json=isFsfLibre,proto3" json:"is_fsf_libre,omitempty"`     // FSF considers it libre/free
	IsOsiApproved bool                   `protobuf:"varint,8,opt,name=is_osi_approved,json=isOsiApproved,proto3" json:"is_osi_approved,omitempty"`
	SeeAlso       []string               `protobuf:"bytes,9,rep,name=see_also,json=seeAlso,proto3" json:"see_also,omitempty"`        // Related URLs
	CrossRefs     []*SPDX_CrossRef       `protobuf:"bytes,10,rep,name=cross_refs,json=crossRefs,proto3" json:"cross_refs,omitempty"` // Structured cross-references with validation info
	Exceptions    []*SPDX_Exception      `protobuf:"bytes,11,rep,name=exceptions,proto3" json:"exceptions,omitempty"`                // SPDX exceptions applied to this license (empty if none)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SPDX) Reset() {
	*x = SPDX{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SPDX) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SPDX) ProtoMessage() {}

func (x *SPDX) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SPDX.ProtoReflect.Descriptor instead.
func (*SPDX) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{2}
}

func (x *SPDX) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *SPDX) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *SPDX) GetDetailsUrl() string {
	if x != nil {
		return x.DetailsUrl
	}
	return ""
}

func (x *SPDX) GetReferenceUrl() string {
	if x != nil {
		return x.ReferenceUrl
	}
	return ""
}

func (x *SPDX) GetIsDeprecated() bool {
	if x != nil {
		return x.IsDeprecated
	}
	return false
}

func (x *SPDX) GetIsFsfLibre() bool {
	if x != nil {
		return x.IsFsfLibre
	}
	return false
}

func (x *SPDX) GetIsOsiApproved() bool {
	if x != nil {
		return x.IsOsiApproved
	}
	return false
}

func (x *SPDX) GetSeeAlso() []string {
	if x != nil {
		return x.SeeAlso
	}
	return nil
}

func (x *SPDX) GetCrossRefs() []*SPDX_CrossRef {
	if x != nil {
		return x.CrossRefs
	}
	return nil
}

func (x *SPDX) GetExceptions() []*SPDX_Exception {
	if x != nil {
		return x.Exceptions
	}
	return nil
}

// OSADL use case with structured obligations.
type OSADL_UseCase struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Name           string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                           // "Binary delivery", "Network service", "Source code delivery"
	ObligationText string                 `protobuf:"bytes,2,opt,name=obligation_text,json=obligationText,proto3" json:"obligation_text,omitempty"` // Human-readable obligation text
	ObligationJson string                 `protobuf:"bytes,3,opt,name=obligation_json,json=obligationJson,proto3" json:"obligation_json,omitempty"` // Machine-readable structured obligations with Language/Action/Term breakdown
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *OSADL_UseCase) Reset() {
	*x = OSADL_UseCase{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OSADL_UseCase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OSADL_UseCase) ProtoMessage() {}

func (x *OSADL_UseCase) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OSADL_UseCase.ProtoReflect.Descriptor instead.
func (*OSADL_UseCase) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{3}
}

func (x *OSADL_UseCase) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *OSADL_UseCase) GetObligationText() string {
	if x != nil {
		return x.ObligationText
	}
	return ""
}

func (x *OSADL_UseCase) GetObligationJson() string {
	if x != nil {
		return x.ObligationJson
	}
	return ""
}

// OSADL compliance metadata providing license analysis and compatibility information.
type OSADL struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	CopyleftClause         bool                   `protobuf:"varint,1,opt,name=copyleft_clause,json=copyleftClause,proto3" json:"copyleft_clause,omitempty"`
	PatentHints            bool                   `protobuf:"varint,2,opt,name=patent_hints,json=patentHints,proto3" json:"patent_hints,omitempty"`
	Compatibility          []string               `protobuf:"bytes,3,rep,name=compatibility,proto3" json:"compatibility,omitempty"`
	DependingCompatibility []string               `protobuf:"bytes,4,rep,name=depending_compatibility,json=dependingCompatibility,proto3" json:"depending_compatibility,omitempty"`
	Incompatibility        []string               `protobuf:"bytes,5,rep,name=incompatibility,proto3" json:"incompatibility,omitempty"`
	UseCases               []*OSADL_UseCase       `protobuf:"bytes,6,rep,name=use_cases,json=useCases,proto3" json:"use_cases,omitempty"` //TODO: Mine data
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *OSADL) Reset() {
	*x = OSADL{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OSADL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OSADL) ProtoMessage() {}

func (x *OSADL) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OSADL.ProtoReflect.Descriptor instead.
func (*OSADL) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{4}
}

func (x *OSADL) GetCopyleftClause() bool {
	if x != nil {
		return x.CopyleftClause
	}
	return false
}

func (x *OSADL) GetPatentHints() bool {
	if x != nil {
		return x.PatentHints
	}
	return false
}

func (x *OSADL) GetCompatibility() []string {
	if x != nil {
		return x.Compatibility
	}
	return nil
}

func (x *OSADL) GetDependingCompatibility() []string {
	if x != nil {
		return x.DependingCompatibility
	}
	return nil
}

func (x *OSADL) GetIncompatibility() []string {
	if x != nil {
		return x.Incompatibility
	}
	return nil
}

func (x *OSADL) GetUseCases() []*OSADL_UseCase {
	if x != nil {
		return x.UseCases
	}
	return nil
}

type LicenseInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier for an individual license
	// - For SPDX registry licenses: Standard SPDX ID (e.g., "MIT", "GPL-2.0-only")
	// - For non-registry licenses: licenseRef format (e.g., "licenseRef-GitLab-Enterprise")
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Best human-readable license name (normalized when possible)
	// - For SPDX licenses: Official SPDX name (e.g., "MIT License", "GNU General Public License v2.0 only")
	// - For non SPDX licenses: Best normalized name from SCANOSS database or original statement
	FullName      string `protobuf:"bytes,2,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseInfo) Reset() {
	*x = LicenseInfo{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseInfo) ProtoMessage() {}

func (x *LicenseInfo) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseInfo.ProtoReflect.Descriptor instead.
func (*LicenseInfo) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{5}
}

func (x *LicenseInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *LicenseInfo) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

type LicenseDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Best human-readable license name (normalized when possible)
	// - For SPDX licenses: Official SPDX name (e.g., "MIT License", "GNU General Public License v2.0 only")
	// - For non SPDX licenses: Best normalized name from SCANOSS database or original statement
	// Note: May match SPDX.full_name for registry licenses, but serves different purpose (best effort vs official registry)
	FullName      string `protobuf:"bytes,1,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	Type          Type   `protobuf:"varint,2,opt,name=type,proto3,enum=scanoss.api.licenses.v2.Type" json:"type,omitempty"`
	Spdx          *SPDX  `protobuf:"bytes,3,opt,name=spdx,proto3" json:"spdx,omitempty"`   // Always present - SPDX.id always populated, other fields empty if not in SPDX License list
	Osadl         *OSADL `protobuf:"bytes,4,opt,name=osadl,proto3" json:"osadl,omitempty"` // Optional - OSADL compliance metadata
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseDetails) Reset() {
	*x = LicenseDetails{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseDetails) ProtoMessage() {}

func (x *LicenseDetails) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseDetails.ProtoReflect.Descriptor instead.
func (*LicenseDetails) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{6}
}

func (x *LicenseDetails) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *LicenseDetails) GetType() Type {
	if x != nil {
		return x.Type
	}
	return Type_UNKNOWN
}

func (x *LicenseDetails) GetSpdx() *SPDX {
	if x != nil {
		return x.Spdx
	}
	return nil
}

func (x *LicenseDetails) GetOsadl() *OSADL {
	if x != nil {
		return x.Osadl
	}
	return nil
}

// GetDetails & GetObligations endpoint
type LicenseRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // SPDX identifier or licenseRef (e.g., "MIT", "licenseRef-GitLab-Enterprise")
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseRequest) Reset() {
	*x = LicenseRequest{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseRequest) ProtoMessage() {}

func (x *LicenseRequest) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseRequest.ProtoReflect.Descriptor instead.
func (*LicenseRequest) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{7}
}

func (x *LicenseRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// Individual component license information
type ComponentLicenseInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Purl          string                 `protobuf:"bytes,1,opt,name=purl,proto3" json:"purl,omitempty"`
	Requirement   string                 `protobuf:"bytes,2,opt,name=requirement,proto3" json:"requirement,omitempty"`
	Version       string                 `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Statement     string                 `protobuf:"bytes,4,opt,name=statement,proto3" json:"statement,omitempty"` // Raw license statement as declared in source code
	Licenses      []*LicenseInfo         `protobuf:"bytes,5,rep,name=licenses,proto3" json:"licenses,omitempty"`   // Individual licenses parsed from the statement with basic info
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentLicenseInfo) Reset() {
	*x = ComponentLicenseInfo{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentLicenseInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentLicenseInfo) ProtoMessage() {}

func (x *ComponentLicenseInfo) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentLicenseInfo.ProtoReflect.Descriptor instead.
func (*ComponentLicenseInfo) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{8}
}

func (x *ComponentLicenseInfo) GetPurl() string {
	if x != nil {
		return x.Purl
	}
	return ""
}

func (x *ComponentLicenseInfo) GetRequirement() string {
	if x != nil {
		return x.Requirement
	}
	return ""
}

func (x *ComponentLicenseInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ComponentLicenseInfo) GetStatement() string {
	if x != nil {
		return x.Statement
	}
	return ""
}

func (x *ComponentLicenseInfo) GetLicenses() []*LicenseInfo {
	if x != nil {
		return x.Licenses
	}
	return nil
}

// GetLicenses endpoint batch response
type BatchLicenseResponse struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Components    []*ComponentLicenseInfo  `protobuf:"bytes,1,rep,name=components,proto3" json:"components,omitempty"` // License info for each component in the batch
	Status        *commonv2.StatusResponse `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchLicenseResponse) Reset() {
	*x = BatchLicenseResponse{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchLicenseResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchLicenseResponse) ProtoMessage() {}

func (x *BatchLicenseResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchLicenseResponse.ProtoReflect.Descriptor instead.
func (*BatchLicenseResponse) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{9}
}

func (x *BatchLicenseResponse) GetComponents() []*ComponentLicenseInfo {
	if x != nil {
		return x.Components
	}
	return nil
}

func (x *BatchLicenseResponse) GetStatus() *commonv2.StatusResponse {
	if x != nil {
		return x.Status
	}
	return nil
}

type LicenseDetailsResponse struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	License       *LicenseDetails          `protobuf:"bytes,1,opt,name=license,proto3" json:"license,omitempty"` // Full license details with all metadata
	Status        *commonv2.StatusResponse `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseDetailsResponse) Reset() {
	*x = LicenseDetailsResponse{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseDetailsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseDetailsResponse) ProtoMessage() {}

func (x *LicenseDetailsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseDetailsResponse.ProtoReflect.Descriptor instead.
func (*LicenseDetailsResponse) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{10}
}

func (x *LicenseDetailsResponse) GetLicense() *LicenseDetails {
	if x != nil {
		return x.License
	}
	return nil
}

func (x *LicenseDetailsResponse) GetStatus() *commonv2.StatusResponse {
	if x != nil {
		return x.Status
	}
	return nil
}

type ObligationsResponse struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Obligations   *OSADL                   `protobuf:"bytes,1,opt,name=obligations,proto3" json:"obligations,omitempty"` // OSADL compliance data with use cases and obligations
	Status        *commonv2.StatusResponse `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ObligationsResponse) Reset() {
	*x = ObligationsResponse{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ObligationsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObligationsResponse) ProtoMessage() {}

func (x *ObligationsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObligationsResponse.ProtoReflect.Descriptor instead.
func (*ObligationsResponse) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{11}
}

func (x *ObligationsResponse) GetObligations() *OSADL {
	if x != nil {
		return x.Obligations
	}
	return nil
}

func (x *ObligationsResponse) GetStatus() *commonv2.StatusResponse {
	if x != nil {
		return x.Status
	}
	return nil
}

var File_scanoss_api_licenses_v2_scanoss_licenses_proto protoreflect.FileDescriptor

const file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc = "" +
	"\n" +
	".scanoss/api/licenses/v2/scanoss-licenses.proto\x12\x17scanoss.api.licenses.v2\x1a*scanoss/api/common/v2/scanoss-common.proto\x1a\x1cgoogle/api/annotations.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"\xc7\x01\n" +
	"\rSPDX_CrossRef\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x19\n" +
	"\bis_valid\x18\x02 \x01(\bR\aisValid\x12\x17\n" +
	"\ais_live\x18\x03 \x01(\bR\x06isLive\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\tR\ttimestamp\x12&\n" +
	"\x0fis_wayback_link\x18\x05 \x01(\bR\risWaybackLink\x12\x14\n" +
	"\x05order\x18\x06 \x01(\x05R\x05order\x12\x14\n" +
	"\x05match\x18\a \x01(\tR\x05match\"\x9e\x01\n" +
	"\x0eSPDX_Exception\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tfull_name\x18\x02 \x01(\tR\bfullName\x12\x1f\n" +
	"\vdetails_url\x18\x03 \x01(\tR\n" +
	"detailsUrl\x12\x19\n" +
	"\bsee_also\x18\x05 \x03(\tR\aseeAlso\x12#\n" +
	"\ris_deprecated\x18\x06 \x01(\bR\fisDeprecated\"\x93\x03\n" +
	"\x04SPDX\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tfull_name\x18\x02 \x01(\tR\bfullName\x12\x1f\n" +
	"\vdetails_url\x18\x04 \x01(\tR\n" +
	"detailsUrl\x12#\n" +
	"\rreference_url\x18\x05 \x01(\tR\freferenceUrl\x12#\n" +
	"\ris_deprecated\x18\x06 \x01(\bR\fisDeprecated\x12 \n" +
	"\fis_fsf_libre\x18\a \x01(\bR\n" +
	"isFsfLibre\x12&\n" +
	"\x0fis_osi_approved\x18\b \x01(\bR\risOsiApproved\x12\x19\n" +
	"\bsee_also\x18\t \x03(\tR\aseeAlso\x12E\n" +
	"\n" +
	"cross_refs\x18\n" +
	" \x03(\v2&.scanoss.api.licenses.v2.SPDX_CrossRefR\tcrossRefs\x12G\n" +
	"\n" +
	"exceptions\x18\v \x03(\v2'.scanoss.api.licenses.v2.SPDX_ExceptionR\n" +
	"exceptions\"u\n" +
	"\rOSADL_UseCase\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12'\n" +
	"\x0fobligation_text\x18\x02 \x01(\tR\x0eobligationText\x12'\n" +
	"\x0fobligation_json\x18\x03 \x01(\tR\x0eobligationJson\"\xa1\x02\n" +
	"\x05OSADL\x12'\n" +
	"\x0fcopyleft_clause\x18\x01 \x01(\bR\x0ecopyleftClause\x12!\n" +
	"\fpatent_hints\x18\x02 \x01(\bR\vpatentHints\x12$\n" +
	"\rcompatibility\x18\x03 \x03(\tR\rcompatibility\x127\n" +
	"\x17depending_compatibility\x18\x04 \x03(\tR\x16dependingCompatibility\x12(\n" +
	"\x0fincompatibility\x18\x05 \x03(\tR\x0fincompatibility\x12C\n" +
	"\tuse_cases\x18\x06 \x03(\v2&.scanoss.api.licenses.v2.OSADL_UseCaseR\buseCases\":\n" +
	"\vLicenseInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tfull_name\x18\x02 \x01(\tR\bfullName\"\xc9\x01\n" +
	"\x0eLicenseDetails\x12\x1b\n" +
	"\tfull_name\x18\x01 \x01(\tR\bfullName\x121\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1d.scanoss.api.licenses.v2.TypeR\x04type\x121\n" +
	"\x04spdx\x18\x03 \x01(\v2\x1d.scanoss.api.licenses.v2.SPDXR\x04spdx\x124\n" +
	"\x05osadl\x18\x04 \x01(\v2\x1e.scanoss.api.licenses.v2.OSADLR\x05osadl\" \n" +
	"\x0eLicenseRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"\xc6\x01\n" +
	"\x14ComponentLicenseInfo\x12\x12\n" +
	"\x04purl\x18\x01 \x01(\tR\x04purl\x12 \n" +
	"\vrequirement\x18\x02 \x01(\tR\vrequirement\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1c\n" +
	"\tstatement\x18\x04 \x01(\tR\tstatement\x12@\n" +
	"\blicenses\x18\x05 \x03(\v2$.scanoss.api.licenses.v2.LicenseInfoR\blicenses\"\xa4\x01\n" +
	"\x14BatchLicenseResponse\x12M\n" +
	"\n" +
	"components\x18\x01 \x03(\v2-.scanoss.api.licenses.v2.ComponentLicenseInfoR\n" +
	"components\x12=\n" +
	"\x06status\x18\x02 \x01(\v2%.scanoss.api.common.v2.StatusResponseR\x06status\"\x9a\x01\n" +
	"\x16LicenseDetailsResponse\x12A\n" +
	"\alicense\x18\x01 \x01(\v2'.scanoss.api.licenses.v2.LicenseDetailsR\alicense\x12=\n" +
	"\x06status\x18\x02 \x01(\v2%.scanoss.api.common.v2.StatusResponseR\x06status\"\x96\x01\n" +
	"\x13ObligationsResponse\x12@\n" +
	"\vobligations\x18\x01 \x01(\v2\x1e.scanoss.api.licenses.v2.OSADLR\vobligations\x12=\n" +
	"\x06status\x18\x02 \x01(\v2%.scanoss.api.common.v2.StatusResponseR\x06status*e\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x0e\n" +
	"\n" +
	"PERMISSIVE\x10\x01\x12\f\n" +
	"\bCOPYLEFT\x10\x02\x12\x0e\n" +
	"\n" +
	"COMMERCIAL\x10\x03\x12\x0f\n" +
	"\vPROPRIETARY\x10\x04\x12\x11\n" +
	"\rPUBLIC_DOMAIN\x10\x052\xac\x04\n" +
	"\aLicense\x12q\n" +
	"\x04Echo\x12\".scanoss.api.common.v2.EchoRequest\x1a#.scanoss.api.common.v2.EchoResponse\" \x82\xd3\xe4\x93\x02\x1a:\x01*\"\x15/api/v2/licenses/echo\x12\x8c\x01\n" +
	"\vGetLicenses\x12,.scanoss.api.common.v2.ComponentBatchRequest\x1a-.scanoss.api.licenses.v2.BatchLicenseResponse\" \x82\xd3\xe4\x93\x02\x1a:\x01*\"\x15/api/v2/licenses/purl\x12\x8b\x01\n" +
	"\n" +
	"GetDetails\x12'.scanoss.api.licenses.v2.LicenseRequest\x1a/.scanoss.api.licenses.v2.LicenseDetailsResponse\"#\x82\xd3\xe4\x93\x02\x1d:\x01*\"\x18/api/v2/licenses/details\x12\x90\x01\n" +
	"\x0eGetObligations\x12'.scanoss.api.licenses.v2.LicenseRequest\x1a,.scanoss.api.licenses.v2.ObligationsResponse\"'\x82\xd3\xe4\x93\x02!:\x01*\"\x1c/api/v2/licenses/obligationsB\x89\x02\x92A\xd2\x01\x12l\n" +
	"\x17SCANOSS License Service\"L\n" +
	"\x10scanoss-licenses\x12#https://github.com/scanoss/licenses\x1a\x13support@scanoss.com2\x032.0*\x01\x012\x10application/json:\x10application/jsonR;\n" +
	"\x03404\x124\n" +
	"*Returned when the resource does not exist.\x12\x06\n" +
	"\x04\x9a\x02\x01\aZ1github.com/scanoss/papi/api/licensesv2;licensesv2b\x06proto3"

var (
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescOnce sync.Once
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescData []byte
)

func file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP() []byte {
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescOnce.Do(func() {
		file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc), len(file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc)))
	})
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescData
}

var file_scanoss_api_licenses_v2_scanoss_licenses_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_scanoss_api_licenses_v2_scanoss_licenses_proto_goTypes = []any{
	(Type)(0),                              // 0: scanoss.api.licenses.v2.Type
	(*SPDX_CrossRef)(nil),                  // 1: scanoss.api.licenses.v2.SPDX_CrossRef
	(*SPDX_Exception)(nil),                 // 2: scanoss.api.licenses.v2.SPDX_Exception
	(*SPDX)(nil),                           // 3: scanoss.api.licenses.v2.SPDX
	(*OSADL_UseCase)(nil),                  // 4: scanoss.api.licenses.v2.OSADL_UseCase
	(*OSADL)(nil),                          // 5: scanoss.api.licenses.v2.OSADL
	(*LicenseInfo)(nil),                    // 6: scanoss.api.licenses.v2.LicenseInfo
	(*LicenseDetails)(nil),                 // 7: scanoss.api.licenses.v2.LicenseDetails
	(*LicenseRequest)(nil),                 // 8: scanoss.api.licenses.v2.LicenseRequest
	(*ComponentLicenseInfo)(nil),           // 9: scanoss.api.licenses.v2.ComponentLicenseInfo
	(*BatchLicenseResponse)(nil),           // 10: scanoss.api.licenses.v2.BatchLicenseResponse
	(*LicenseDetailsResponse)(nil),         // 11: scanoss.api.licenses.v2.LicenseDetailsResponse
	(*ObligationsResponse)(nil),            // 12: scanoss.api.licenses.v2.ObligationsResponse
	(*commonv2.StatusResponse)(nil),        // 13: scanoss.api.common.v2.StatusResponse
	(*commonv2.EchoRequest)(nil),           // 14: scanoss.api.common.v2.EchoRequest
	(*commonv2.ComponentBatchRequest)(nil), // 15: scanoss.api.common.v2.ComponentBatchRequest
	(*commonv2.EchoResponse)(nil),          // 16: scanoss.api.common.v2.EchoResponse
}
var file_scanoss_api_licenses_v2_scanoss_licenses_proto_depIdxs = []int32{
	1,  // 0: scanoss.api.licenses.v2.SPDX.cross_refs:type_name -> scanoss.api.licenses.v2.SPDX_CrossRef
	2,  // 1: scanoss.api.licenses.v2.SPDX.exceptions:type_name -> scanoss.api.licenses.v2.SPDX_Exception
	4,  // 2: scanoss.api.licenses.v2.OSADL.use_cases:type_name -> scanoss.api.licenses.v2.OSADL_UseCase
	0,  // 3: scanoss.api.licenses.v2.LicenseDetails.type:type_name -> scanoss.api.licenses.v2.Type
	3,  // 4: scanoss.api.licenses.v2.LicenseDetails.spdx:type_name -> scanoss.api.licenses.v2.SPDX
	5,  // 5: scanoss.api.licenses.v2.LicenseDetails.osadl:type_name -> scanoss.api.licenses.v2.OSADL
	6,  // 6: scanoss.api.licenses.v2.ComponentLicenseInfo.licenses:type_name -> scanoss.api.licenses.v2.LicenseInfo
	9,  // 7: scanoss.api.licenses.v2.BatchLicenseResponse.components:type_name -> scanoss.api.licenses.v2.ComponentLicenseInfo
	13, // 8: scanoss.api.licenses.v2.BatchLicenseResponse.status:type_name -> scanoss.api.common.v2.StatusResponse
	7,  // 9: scanoss.api.licenses.v2.LicenseDetailsResponse.license:type_name -> scanoss.api.licenses.v2.LicenseDetails
	13, // 10: scanoss.api.licenses.v2.LicenseDetailsResponse.status:type_name -> scanoss.api.common.v2.StatusResponse
	5,  // 11: scanoss.api.licenses.v2.ObligationsResponse.obligations:type_name -> scanoss.api.licenses.v2.OSADL
	13, // 12: scanoss.api.licenses.v2.ObligationsResponse.status:type_name -> scanoss.api.common.v2.StatusResponse
	14, // 13: scanoss.api.licenses.v2.License.Echo:input_type -> scanoss.api.common.v2.EchoRequest
	15, // 14: scanoss.api.licenses.v2.License.GetLicenses:input_type -> scanoss.api.common.v2.ComponentBatchRequest
	8,  // 15: scanoss.api.licenses.v2.License.GetDetails:input_type -> scanoss.api.licenses.v2.LicenseRequest
	8,  // 16: scanoss.api.licenses.v2.License.GetObligations:input_type -> scanoss.api.licenses.v2.LicenseRequest
	16, // 17: scanoss.api.licenses.v2.License.Echo:output_type -> scanoss.api.common.v2.EchoResponse
	10, // 18: scanoss.api.licenses.v2.License.GetLicenses:output_type -> scanoss.api.licenses.v2.BatchLicenseResponse
	11, // 19: scanoss.api.licenses.v2.License.GetDetails:output_type -> scanoss.api.licenses.v2.LicenseDetailsResponse
	12, // 20: scanoss.api.licenses.v2.License.GetObligations:output_type -> scanoss.api.licenses.v2.ObligationsResponse
	17, // [17:21] is the sub-list for method output_type
	13, // [13:17] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_scanoss_api_licenses_v2_scanoss_licenses_proto_init() }
func file_scanoss_api_licenses_v2_scanoss_licenses_proto_init() {
	if File_scanoss_api_licenses_v2_scanoss_licenses_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc), len(file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_scanoss_api_licenses_v2_scanoss_licenses_proto_goTypes,
		DependencyIndexes: file_scanoss_api_licenses_v2_scanoss_licenses_proto_depIdxs,
		EnumInfos:         file_scanoss_api_licenses_v2_scanoss_licenses_proto_enumTypes,
		MessageInfos:      file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes,
	}.Build()
	File_scanoss_api_licenses_v2_scanoss_licenses_proto = out.File
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_goTypes = nil
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_depIdxs = nil
}
