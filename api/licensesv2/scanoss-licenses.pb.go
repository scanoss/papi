//
//SPDX-License-Identifier: MIT
//
//Copyright (c) 2025, SCANOSS
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in
//all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//THE SOFTWARE.

//**
// License definition details
//*

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.31.1
// source: scanoss/api/licenses/v2/scanoss-licenses.proto

package licensesv2

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	commonv2 "github.com/scanoss/papi/api/commonv2"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type LicenseType int32

const (
	LicenseType_UNKNOWN       LicenseType = 0
	LicenseType_PERMISSIVE    LicenseType = 1
	LicenseType_COPYLEFT      LicenseType = 2
	LicenseType_COMMERCIAL    LicenseType = 3
	LicenseType_PROPRIETARY   LicenseType = 4
	LicenseType_PUBLIC_DOMAIN LicenseType = 5
)

// Enum value maps for LicenseType.
var (
	LicenseType_name = map[int32]string{
		0: "UNKNOWN",
		1: "PERMISSIVE",
		2: "COPYLEFT",
		3: "COMMERCIAL",
		4: "PROPRIETARY",
		5: "PUBLIC_DOMAIN",
	}
	LicenseType_value = map[string]int32{
		"UNKNOWN":       0,
		"PERMISSIVE":    1,
		"COPYLEFT":      2,
		"COMMERCIAL":    3,
		"PROPRIETARY":   4,
		"PUBLIC_DOMAIN": 5,
	}
)

func (x LicenseType) Enum() *LicenseType {
	p := new(LicenseType)
	*p = x
	return p
}

func (x LicenseType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LicenseType) Descriptor() protoreflect.EnumDescriptor {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_enumTypes[0].Descriptor()
}

func (LicenseType) Type() protoreflect.EnumType {
	return &file_scanoss_api_licenses_v2_scanoss_licenses_proto_enumTypes[0]
}

func (x LicenseType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LicenseType.Descriptor instead.
func (LicenseType) EnumDescriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{0}
}

type ComponentLicenseResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// License info for the component
	Component     *ComponentLicenseInfo    `protobuf:"bytes,1,opt,name=component,proto3" json:"component,omitempty"`
	Status        *commonv2.StatusResponse `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentLicenseResponse) Reset() {
	*x = ComponentLicenseResponse{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentLicenseResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentLicenseResponse) ProtoMessage() {}

func (x *ComponentLicenseResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentLicenseResponse.ProtoReflect.Descriptor instead.
func (*ComponentLicenseResponse) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{0}
}

func (x *ComponentLicenseResponse) GetComponent() *ComponentLicenseInfo {
	if x != nil {
		return x.Component
	}
	return nil
}

func (x *ComponentLicenseResponse) GetStatus() *commonv2.StatusResponse {
	if x != nil {
		return x.Status
	}
	return nil
}

type ComponentsLicenseResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// License info for each component in the batch
	Components    []*ComponentLicenseInfo  `protobuf:"bytes,1,rep,name=components,proto3" json:"components,omitempty"`
	Status        *commonv2.StatusResponse `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentsLicenseResponse) Reset() {
	*x = ComponentsLicenseResponse{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentsLicenseResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentsLicenseResponse) ProtoMessage() {}

func (x *ComponentsLicenseResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentsLicenseResponse.ProtoReflect.Descriptor instead.
func (*ComponentsLicenseResponse) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{1}
}

func (x *ComponentsLicenseResponse) GetComponents() []*ComponentLicenseInfo {
	if x != nil {
		return x.Components
	}
	return nil
}

func (x *ComponentsLicenseResponse) GetStatus() *commonv2.StatusResponse {
	if x != nil {
		return x.Status
	}
	return nil
}

type LicenseDetailsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Full license details with all metadata
	License       *LicenseDetails          `protobuf:"bytes,1,opt,name=license,proto3" json:"license,omitempty"`
	Status        *commonv2.StatusResponse `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseDetailsResponse) Reset() {
	*x = LicenseDetailsResponse{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseDetailsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseDetailsResponse) ProtoMessage() {}

func (x *LicenseDetailsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseDetailsResponse.ProtoReflect.Descriptor instead.
func (*LicenseDetailsResponse) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{2}
}

func (x *LicenseDetailsResponse) GetLicense() *LicenseDetails {
	if x != nil {
		return x.License
	}
	return nil
}

func (x *LicenseDetailsResponse) GetStatus() *commonv2.StatusResponse {
	if x != nil {
		return x.Status
	}
	return nil
}

type ObligationsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// OSADL compliance data with use cases and obligations
	Obligations   *OSADL                   `protobuf:"bytes,1,opt,name=obligations,proto3" json:"obligations,omitempty"`
	Status        *commonv2.StatusResponse `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ObligationsResponse) Reset() {
	*x = ObligationsResponse{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ObligationsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObligationsResponse) ProtoMessage() {}

func (x *ObligationsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObligationsResponse.ProtoReflect.Descriptor instead.
func (*ObligationsResponse) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{3}
}

func (x *ObligationsResponse) GetObligations() *OSADL {
	if x != nil {
		return x.Obligations
	}
	return nil
}

func (x *ObligationsResponse) GetStatus() *commonv2.StatusResponse {
	if x != nil {
		return x.Status
	}
	return nil
}

// SPDX license registry metadata.
type SPDX struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SPDX license identifier, "GPL-2.0-only", "MIT"
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Official SPDX registry name (empty if license not in SPDX registry)
	FullName string `protobuf:"bytes,2,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	// JSON API URL for full details
	DetailsUrl string `protobuf:"bytes,4,opt,name=details_url,json=detailsUrl,proto3" json:"details_url,omitempty"`
	// HTML page URL
	ReferenceUrl string `protobuf:"bytes,5,opt,name=reference_url,json=referenceUrl,proto3" json:"reference_url,omitempty"`
	IsDeprecated bool   `protobuf:"varint,6,opt,name=is_deprecated,json=isDeprecated,proto3" json:"is_deprecated,omitempty"`
	// FSF considers it libre/free
	IsFsfLibre    bool `protobuf:"varint,7,opt,name=is_fsf_libre,json=isFsfLibre,proto3" json:"is_fsf_libre,omitempty"`
	IsOsiApproved bool `protobuf:"varint,8,opt,name=is_osi_approved,json=isOsiApproved,proto3" json:"is_osi_approved,omitempty"`
	// Related URLs
	SeeAlso []string `protobuf:"bytes,9,rep,name=see_also,json=seeAlso,proto3" json:"see_also,omitempty"`
	// Structured cross-references with validation info
	CrossRefs []*SPDX_SPDXCrossRef `protobuf:"bytes,10,rep,name=cross_refs,json=crossRefs,proto3" json:"cross_refs,omitempty"`
	// SPDX exceptions applied to this license (empty if none)
	Exceptions    []*SPDX_SPDXException `protobuf:"bytes,11,rep,name=exceptions,proto3" json:"exceptions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SPDX) Reset() {
	*x = SPDX{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SPDX) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SPDX) ProtoMessage() {}

func (x *SPDX) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SPDX.ProtoReflect.Descriptor instead.
func (*SPDX) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{4}
}

func (x *SPDX) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *SPDX) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *SPDX) GetDetailsUrl() string {
	if x != nil {
		return x.DetailsUrl
	}
	return ""
}

func (x *SPDX) GetReferenceUrl() string {
	if x != nil {
		return x.ReferenceUrl
	}
	return ""
}

func (x *SPDX) GetIsDeprecated() bool {
	if x != nil {
		return x.IsDeprecated
	}
	return false
}

func (x *SPDX) GetIsFsfLibre() bool {
	if x != nil {
		return x.IsFsfLibre
	}
	return false
}

func (x *SPDX) GetIsOsiApproved() bool {
	if x != nil {
		return x.IsOsiApproved
	}
	return false
}

func (x *SPDX) GetSeeAlso() []string {
	if x != nil {
		return x.SeeAlso
	}
	return nil
}

func (x *SPDX) GetCrossRefs() []*SPDX_SPDXCrossRef {
	if x != nil {
		return x.CrossRefs
	}
	return nil
}

func (x *SPDX) GetExceptions() []*SPDX_SPDXException {
	if x != nil {
		return x.Exceptions
	}
	return nil
}

// OSADL compliance metadata providing license analysis and compatibility information.
type OSADL struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	CopyleftClause         bool                   `protobuf:"varint,1,opt,name=copyleft_clause,json=copyleftClause,proto3" json:"copyleft_clause,omitempty"`
	PatentHints            bool                   `protobuf:"varint,2,opt,name=patent_hints,json=patentHints,proto3" json:"patent_hints,omitempty"`
	Compatibility          []string               `protobuf:"bytes,3,rep,name=compatibility,proto3" json:"compatibility,omitempty"`
	DependingCompatibility []string               `protobuf:"bytes,4,rep,name=depending_compatibility,json=dependingCompatibility,proto3" json:"depending_compatibility,omitempty"`
	Incompatibility        []string               `protobuf:"bytes,5,rep,name=incompatibility,proto3" json:"incompatibility,omitempty"`
	UseCases               []*OSADL_OSADLUseCase  `protobuf:"bytes,6,rep,name=use_cases,json=useCases,proto3" json:"use_cases,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *OSADL) Reset() {
	*x = OSADL{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OSADL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OSADL) ProtoMessage() {}

func (x *OSADL) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OSADL.ProtoReflect.Descriptor instead.
func (*OSADL) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{5}
}

func (x *OSADL) GetCopyleftClause() bool {
	if x != nil {
		return x.CopyleftClause
	}
	return false
}

func (x *OSADL) GetPatentHints() bool {
	if x != nil {
		return x.PatentHints
	}
	return false
}

func (x *OSADL) GetCompatibility() []string {
	if x != nil {
		return x.Compatibility
	}
	return nil
}

func (x *OSADL) GetDependingCompatibility() []string {
	if x != nil {
		return x.DependingCompatibility
	}
	return nil
}

func (x *OSADL) GetIncompatibility() []string {
	if x != nil {
		return x.Incompatibility
	}
	return nil
}

func (x *OSADL) GetUseCases() []*OSADL_OSADLUseCase {
	if x != nil {
		return x.UseCases
	}
	return nil
}

// Individual license identification with SPDX ID and human-readable name
type LicenseInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// License identifier:
	//   - For SPDX registry licenses: Standard SPDX ID
	//   - For non-registry licenses: licenseRef-<custom_license_name>
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human-readable license name.
	FullName      string `protobuf:"bytes,2,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseInfo) Reset() {
	*x = LicenseInfo{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseInfo) ProtoMessage() {}

func (x *LicenseInfo) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseInfo.ProtoReflect.Descriptor instead.
func (*LicenseInfo) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{6}
}

func (x *LicenseInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *LicenseInfo) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

type LicenseDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Best human-readable license name (normalized when possible)
	// - For SPDX licenses: Official SPDX name (e.g., "MIT License", "GNU General Public License v2.0 only")
	// - For non SPDX licenses: Best normalized name from SCANOSS database or original statement
	// Note: May match SPDX.full_name for registry licenses, but serves different purpose (best effort vs official registry)
	FullName      string      `protobuf:"bytes,1,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	Type          LicenseType `protobuf:"varint,2,opt,name=type,proto3,enum=scanoss.api.licenses.v2.LicenseType" json:"type,omitempty"`
	Spdx          *SPDX       `protobuf:"bytes,3,opt,name=spdx,proto3" json:"spdx,omitempty"`   // Always present - SPDX.id always populated, other fields empty if not in SPDX License list
	Osadl         *OSADL      `protobuf:"bytes,4,opt,name=osadl,proto3" json:"osadl,omitempty"` // Optional - OSADL compliance metadata
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseDetails) Reset() {
	*x = LicenseDetails{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseDetails) ProtoMessage() {}

func (x *LicenseDetails) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseDetails.ProtoReflect.Descriptor instead.
func (*LicenseDetails) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{7}
}

func (x *LicenseDetails) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *LicenseDetails) GetType() LicenseType {
	if x != nil {
		return x.Type
	}
	return LicenseType_UNKNOWN
}

func (x *LicenseDetails) GetSpdx() *SPDX {
	if x != nil {
		return x.Spdx
	}
	return nil
}

func (x *LicenseDetails) GetOsadl() *OSADL {
	if x != nil {
		return x.Osadl
	}
	return nil
}

// GetDetails & GetObligations endpoint
type LicenseRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // SPDX identifier or licenseRef (e.g., "MIT", "licenseRef-GitLab-Enterprise")
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseRequest) Reset() {
	*x = LicenseRequest{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseRequest) ProtoMessage() {}

func (x *LicenseRequest) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseRequest.ProtoReflect.Descriptor instead.
func (*LicenseRequest) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{8}
}

func (x *LicenseRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// License information for a specific component identified by PURL and version.
type ComponentLicenseInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Package URL (PURL) uniquely identifying the component. See Common API Types documentation for format and resolution logic.
	Purl string `protobuf:"bytes,1,opt,name=purl,proto3" json:"purl,omitempty"`
	// Echoes the client's version constraint from the request. See Common API Types documentation for resolution logic
	Requirement string `protobuf:"bytes,2,opt,name=requirement,proto3" json:"requirement,omitempty"`
	// Specific version of the component that was analyzed
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// SPDX expression when licensing terms are clearly determinable from source analysis
	Statement string `protobuf:"bytes,4,opt,name=statement,proto3" json:"statement,omitempty"`
	// Individual licenses identified in the component
	Licenses      []*LicenseInfo `protobuf:"bytes,5,rep,name=licenses,proto3" json:"licenses,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentLicenseInfo) Reset() {
	*x = ComponentLicenseInfo{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentLicenseInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentLicenseInfo) ProtoMessage() {}

func (x *ComponentLicenseInfo) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentLicenseInfo.ProtoReflect.Descriptor instead.
func (*ComponentLicenseInfo) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{9}
}

func (x *ComponentLicenseInfo) GetPurl() string {
	if x != nil {
		return x.Purl
	}
	return ""
}

func (x *ComponentLicenseInfo) GetRequirement() string {
	if x != nil {
		return x.Requirement
	}
	return ""
}

func (x *ComponentLicenseInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ComponentLicenseInfo) GetStatement() string {
	if x != nil {
		return x.Statement
	}
	return ""
}

func (x *ComponentLicenseInfo) GetLicenses() []*LicenseInfo {
	if x != nil {
		return x.Licenses
	}
	return nil
}

type SPDX_SPDXCrossRef struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Url           string                 `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	IsValid       bool                   `protobuf:"varint,2,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
	IsLive        bool                   `protobuf:"varint,3,opt,name=is_live,json=isLive,proto3" json:"is_live,omitempty"`
	Timestamp     string                 `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	IsWaybackLink bool                   `protobuf:"varint,5,opt,name=is_wayback_link,json=isWaybackLink,proto3" json:"is_wayback_link,omitempty"`
	Order         int32                  `protobuf:"varint,6,opt,name=order,proto3" json:"order,omitempty"`
	Match         string                 `protobuf:"bytes,7,opt,name=match,proto3" json:"match,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SPDX_SPDXCrossRef) Reset() {
	*x = SPDX_SPDXCrossRef{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SPDX_SPDXCrossRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SPDX_SPDXCrossRef) ProtoMessage() {}

func (x *SPDX_SPDXCrossRef) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SPDX_SPDXCrossRef.ProtoReflect.Descriptor instead.
func (*SPDX_SPDXCrossRef) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{4, 0}
}

func (x *SPDX_SPDXCrossRef) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *SPDX_SPDXCrossRef) GetIsValid() bool {
	if x != nil {
		return x.IsValid
	}
	return false
}

func (x *SPDX_SPDXCrossRef) GetIsLive() bool {
	if x != nil {
		return x.IsLive
	}
	return false
}

func (x *SPDX_SPDXCrossRef) GetTimestamp() string {
	if x != nil {
		return x.Timestamp
	}
	return ""
}

func (x *SPDX_SPDXCrossRef) GetIsWaybackLink() bool {
	if x != nil {
		return x.IsWaybackLink
	}
	return false
}

func (x *SPDX_SPDXCrossRef) GetOrder() int32 {
	if x != nil {
		return x.Order
	}
	return 0
}

func (x *SPDX_SPDXCrossRef) GetMatch() string {
	if x != nil {
		return x.Match
	}
	return ""
}

// SPDX exception grant an exception to a license condition or additional
// permissions beyond those granted in a license;
// NOTE: this is not a stand-alone license
type SPDX_SPDXException struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SPDX exception identifier, "Classpath-exception-2.0"
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// SPDX exception registry name, "Classpath exception 2.0"
	FullName string `protobuf:"bytes,2,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	// SPDX exception JSON URL
	DetailsUrl string `protobuf:"bytes,3,opt,name=details_url,json=detailsUrl,proto3" json:"details_url,omitempty"`
	// Reference URLs
	SeeAlso       []string `protobuf:"bytes,5,rep,name=see_also,json=seeAlso,proto3" json:"see_also,omitempty"`
	IsDeprecated  bool     `protobuf:"varint,6,opt,name=is_deprecated,json=isDeprecated,proto3" json:"is_deprecated,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SPDX_SPDXException) Reset() {
	*x = SPDX_SPDXException{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SPDX_SPDXException) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SPDX_SPDXException) ProtoMessage() {}

func (x *SPDX_SPDXException) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SPDX_SPDXException.ProtoReflect.Descriptor instead.
func (*SPDX_SPDXException) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{4, 1}
}

func (x *SPDX_SPDXException) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *SPDX_SPDXException) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *SPDX_SPDXException) GetDetailsUrl() string {
	if x != nil {
		return x.DetailsUrl
	}
	return ""
}

func (x *SPDX_SPDXException) GetSeeAlso() []string {
	if x != nil {
		return x.SeeAlso
	}
	return nil
}

func (x *SPDX_SPDXException) GetIsDeprecated() bool {
	if x != nil {
		return x.IsDeprecated
	}
	return false
}

// OSADL use case with structured obligations.
type OSADL_OSADLUseCase struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// "Binary delivery", "Network service", "Source code delivery"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Human-readable obligation text
	ObligationText string `protobuf:"bytes,2,opt,name=obligation_text,json=obligationText,proto3" json:"obligation_text,omitempty"`
	// Machine-readable structured obligations with Language/Action/Term breakdown
	ObligationJson string `protobuf:"bytes,3,opt,name=obligation_json,json=obligationJson,proto3" json:"obligation_json,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *OSADL_OSADLUseCase) Reset() {
	*x = OSADL_OSADLUseCase{}
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OSADL_OSADLUseCase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OSADL_OSADLUseCase) ProtoMessage() {}

func (x *OSADL_OSADLUseCase) ProtoReflect() protoreflect.Message {
	mi := &file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OSADL_OSADLUseCase.ProtoReflect.Descriptor instead.
func (*OSADL_OSADLUseCase) Descriptor() ([]byte, []int) {
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP(), []int{5, 0}
}

func (x *OSADL_OSADLUseCase) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *OSADL_OSADLUseCase) GetObligationText() string {
	if x != nil {
		return x.ObligationText
	}
	return ""
}

func (x *OSADL_OSADLUseCase) GetObligationJson() string {
	if x != nil {
		return x.ObligationJson
	}
	return ""
}

var File_scanoss_api_licenses_v2_scanoss_licenses_proto protoreflect.FileDescriptor

const file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc = "" +
	"\n" +
	".scanoss/api/licenses/v2/scanoss-licenses.proto\x12\x17scanoss.api.licenses.v2\x1a*scanoss/api/common/v2/scanoss-common.proto\x1a\x1cgoogle/api/annotations.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"\xd0\x03\n" +
	"\x18ComponentLicenseResponse\x12K\n" +
	"\tcomponent\x18\x01 \x01(\v2-.scanoss.api.licenses.v2.ComponentLicenseInfoR\tcomponent\x12=\n" +
	"\x06status\x18\x02 \x01(\v2%.scanoss.api.common.v2.StatusResponseR\x06status:\xa7\x02\x92A\xa3\x02\n" +
	"\xa0\x02J\x9d\x02{\"component\":{\"purl\": \"pkg:github/scanoss/engine@1.0.0\", \"requirement\": \"\", \"version\": \"1.0.0\", \"statement\": \"GPL-2.0\", \"licenses\": [{\"id\": \"GPL-2.0\", \"full_name\": \"GNU General Public License v2.0 only\"}]}, \"status\": {\"status\": \"SUCCESS\", \"message\": \"Licenses Successfully retrieved\"}}\"\xfd\x04\n" +
	"\x19ComponentsLicenseResponse\x12M\n" +
	"\n" +
	"components\x18\x01 \x03(\v2-.scanoss.api.licenses.v2.ComponentLicenseInfoR\n" +
	"components\x12=\n" +
	"\x06status\x18\x02 \x01(\v2%.scanoss.api.common.v2.StatusResponseR\x06status:\xd1\x03\x92A\xcd\x03\n" +
	"\xca\x03J\xc7\x03{\"components\":[{\"purl\": \"pkg:github/scanoss/engine@1.0.0\", \"requirement\": \"\", \"version\": \"1.0.0\", \"statement\": \"GPL-2.0\", \"licenses\": [{\"id\": \"GPL-2.0\", \"full_name\": \"GNU General Public License v2.0 only\"}]}, {\"purl\": \"pkg:github/scanoss/scanoss.py@v1.30.0\",\"requirement\": \"\",\"version\": \"v1.30.0\",\"statement\": \"MIT\", \"licenses\": [{\"id\": \"MIT\",\"full_name\": \"MIT License\"}]}  ], \"status\": {\"status\": \"SUCCESS\", \"message\": \"Licenses Successfully retrieved\"}}\"\x9a\x01\n" +
	"\x16LicenseDetailsResponse\x12A\n" +
	"\alicense\x18\x01 \x01(\v2'.scanoss.api.licenses.v2.LicenseDetailsR\alicense\x12=\n" +
	"\x06status\x18\x02 \x01(\v2%.scanoss.api.common.v2.StatusResponseR\x06status\"\x96\x01\n" +
	"\x13ObligationsResponse\x12@\n" +
	"\vobligations\x18\x01 \x01(\v2\x1e.scanoss.api.licenses.v2.OSADLR\vobligations\x12=\n" +
	"\x06status\x18\x02 \x01(\v2%.scanoss.api.common.v2.StatusResponseR\x06status\"\x84\x06\n" +
	"\x04SPDX\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tfull_name\x18\x02 \x01(\tR\bfullName\x12\x1f\n" +
	"\vdetails_url\x18\x04 \x01(\tR\n" +
	"detailsUrl\x12#\n" +
	"\rreference_url\x18\x05 \x01(\tR\freferenceUrl\x12#\n" +
	"\ris_deprecated\x18\x06 \x01(\bR\fisDeprecated\x12 \n" +
	"\fis_fsf_libre\x18\a \x01(\bR\n" +
	"isFsfLibre\x12&\n" +
	"\x0fis_osi_approved\x18\b \x01(\bR\risOsiApproved\x12\x19\n" +
	"\bsee_also\x18\t \x03(\tR\aseeAlso\x12I\n" +
	"\n" +
	"cross_refs\x18\n" +
	" \x03(\v2*.scanoss.api.licenses.v2.SPDX.SPDXCrossRefR\tcrossRefs\x12K\n" +
	"\n" +
	"exceptions\x18\v \x03(\v2+.scanoss.api.licenses.v2.SPDX.SPDXExceptionR\n" +
	"exceptions\x1a\xc6\x01\n" +
	"\fSPDXCrossRef\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x19\n" +
	"\bis_valid\x18\x02 \x01(\bR\aisValid\x12\x17\n" +
	"\ais_live\x18\x03 \x01(\bR\x06isLive\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\tR\ttimestamp\x12&\n" +
	"\x0fis_wayback_link\x18\x05 \x01(\bR\risWaybackLink\x12\x14\n" +
	"\x05order\x18\x06 \x01(\x05R\x05order\x12\x14\n" +
	"\x05match\x18\a \x01(\tR\x05match\x1a\x9d\x01\n" +
	"\rSPDXException\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tfull_name\x18\x02 \x01(\tR\bfullName\x12\x1f\n" +
	"\vdetails_url\x18\x03 \x01(\tR\n" +
	"detailsUrl\x12\x19\n" +
	"\bsee_also\x18\x05 \x03(\tR\aseeAlso\x12#\n" +
	"\ris_deprecated\x18\x06 \x01(\bR\fisDeprecated\"\x9c\x03\n" +
	"\x05OSADL\x12'\n" +
	"\x0fcopyleft_clause\x18\x01 \x01(\bR\x0ecopyleftClause\x12!\n" +
	"\fpatent_hints\x18\x02 \x01(\bR\vpatentHints\x12$\n" +
	"\rcompatibility\x18\x03 \x03(\tR\rcompatibility\x127\n" +
	"\x17depending_compatibility\x18\x04 \x03(\tR\x16dependingCompatibility\x12(\n" +
	"\x0fincompatibility\x18\x05 \x03(\tR\x0fincompatibility\x12H\n" +
	"\tuse_cases\x18\x06 \x03(\v2+.scanoss.api.licenses.v2.OSADL.OSADLUseCaseR\buseCases\x1at\n" +
	"\fOSADLUseCase\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12'\n" +
	"\x0fobligation_text\x18\x02 \x01(\tR\x0eobligationText\x12'\n" +
	"\x0fobligation_json\x18\x03 \x01(\tR\x0eobligationJson\"\x89\x01\n" +
	"\vLicenseInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tfull_name\x18\x02 \x01(\tR\bfullName:M\x92AJ\n" +
	"HJF{\"id\": \"GPL-2.0\", \"full_name\": \"GNU General Public License v2.0 only\"}\"\xd0\x01\n" +
	"\x0eLicenseDetails\x12\x1b\n" +
	"\tfull_name\x18\x01 \x01(\tR\bfullName\x128\n" +
	"\x04type\x18\x02 \x01(\x0e2$.scanoss.api.licenses.v2.LicenseTypeR\x04type\x121\n" +
	"\x04spdx\x18\x03 \x01(\v2\x1d.scanoss.api.licenses.v2.SPDXR\x04spdx\x124\n" +
	"\x05osadl\x18\x04 \x01(\v2\x1e.scanoss.api.licenses.v2.OSADLR\x05osadl\" \n" +
	"\x0eLicenseRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"\xc6\x01\n" +
	"\x14ComponentLicenseInfo\x12\x12\n" +
	"\x04purl\x18\x01 \x01(\tR\x04purl\x12 \n" +
	"\vrequirement\x18\x02 \x01(\tR\vrequirement\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1c\n" +
	"\tstatement\x18\x04 \x01(\tR\tstatement\x12@\n" +
	"\blicenses\x18\x05 \x03(\v2$.scanoss.api.licenses.v2.LicenseInfoR\blicenses*l\n" +
	"\vLicenseType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x0e\n" +
	"\n" +
	"PERMISSIVE\x10\x01\x12\f\n" +
	"\bCOPYLEFT\x10\x02\x12\x0e\n" +
	"\n" +
	"COMMERCIAL\x10\x03\x12\x0f\n" +
	"\vPROPRIETARY\x10\x04\x12\x11\n" +
	"\rPUBLIC_DOMAIN\x10\x052\xda\x05\n" +
	"\aLicense\x12q\n" +
	"\x04Echo\x12\".scanoss.api.common.v2.EchoRequest\x1a#.scanoss.api.common.v2.EchoResponse\" \x82\xd3\xe4\x93\x02\x1a:\x01*\"\x15/api/v2/licenses/echo\x12\x96\x01\n" +
	"\x14GetComponentLicenses\x12'.scanoss.api.common.v2.ComponentRequest\x1a1.scanoss.api.licenses.v2.ComponentLicenseResponse\"\"\x82\xd3\xe4\x93\x02\x1c\x12\x1a/api/v2/licenses/component\x12\xa1\x01\n" +
	"\x15GetComponentsLicenses\x12,.scanoss.api.common.v2.ComponentBatchRequest\x1a2.scanoss.api.licenses.v2.ComponentsLicenseResponse\"&\x82\xd3\xe4\x93\x02 :\x01*\"\x1b/api/v2/licenses/components\x12\x8b\x01\n" +
	"\n" +
	"GetDetails\x12'.scanoss.api.licenses.v2.LicenseRequest\x1a/.scanoss.api.licenses.v2.LicenseDetailsResponse\"#\x82\xd3\xe4\x93\x02\x1d:\x01*\"\x18/api/v2/licenses/details\x12\x90\x01\n" +
	"\x0eGetObligations\x12'.scanoss.api.licenses.v2.LicenseRequest\x1a,.scanoss.api.licenses.v2.ObligationsResponse\"'\x82\xd3\xe4\x93\x02!:\x01*\"\x1c/api/v2/licenses/obligationsB\x95\x02\x92A\xde\x01\x12\xb4\x01\n" +
	"\x17SCANOSS License Service\x12FLicense service provides license intelligence for software components.\"L\n" +
	"\x10scanoss-licenses\x12#https://github.com/scanoss/licenses\x1a\x13support@scanoss.com2\x032.0*\x01\x012\x10application/json:\x10application/jsonZ1github.com/scanoss/papi/api/licensesv2;licensesv2b\x06proto3"

var (
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescOnce sync.Once
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescData []byte
)

func file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescGZIP() []byte {
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescOnce.Do(func() {
		file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc), len(file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc)))
	})
	return file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDescData
}

var file_scanoss_api_licenses_v2_scanoss_licenses_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_scanoss_api_licenses_v2_scanoss_licenses_proto_goTypes = []any{
	(LicenseType)(0),                       // 0: scanoss.api.licenses.v2.LicenseType
	(*ComponentLicenseResponse)(nil),       // 1: scanoss.api.licenses.v2.ComponentLicenseResponse
	(*ComponentsLicenseResponse)(nil),      // 2: scanoss.api.licenses.v2.ComponentsLicenseResponse
	(*LicenseDetailsResponse)(nil),         // 3: scanoss.api.licenses.v2.LicenseDetailsResponse
	(*ObligationsResponse)(nil),            // 4: scanoss.api.licenses.v2.ObligationsResponse
	(*SPDX)(nil),                           // 5: scanoss.api.licenses.v2.SPDX
	(*OSADL)(nil),                          // 6: scanoss.api.licenses.v2.OSADL
	(*LicenseInfo)(nil),                    // 7: scanoss.api.licenses.v2.LicenseInfo
	(*LicenseDetails)(nil),                 // 8: scanoss.api.licenses.v2.LicenseDetails
	(*LicenseRequest)(nil),                 // 9: scanoss.api.licenses.v2.LicenseRequest
	(*ComponentLicenseInfo)(nil),           // 10: scanoss.api.licenses.v2.ComponentLicenseInfo
	(*SPDX_SPDXCrossRef)(nil),              // 11: scanoss.api.licenses.v2.SPDX.SPDXCrossRef
	(*SPDX_SPDXException)(nil),             // 12: scanoss.api.licenses.v2.SPDX.SPDXException
	(*OSADL_OSADLUseCase)(nil),             // 13: scanoss.api.licenses.v2.OSADL.OSADLUseCase
	(*commonv2.StatusResponse)(nil),        // 14: scanoss.api.common.v2.StatusResponse
	(*commonv2.EchoRequest)(nil),           // 15: scanoss.api.common.v2.EchoRequest
	(*commonv2.ComponentRequest)(nil),      // 16: scanoss.api.common.v2.ComponentRequest
	(*commonv2.ComponentBatchRequest)(nil), // 17: scanoss.api.common.v2.ComponentBatchRequest
	(*commonv2.EchoResponse)(nil),          // 18: scanoss.api.common.v2.EchoResponse
}
var file_scanoss_api_licenses_v2_scanoss_licenses_proto_depIdxs = []int32{
	10, // 0: scanoss.api.licenses.v2.ComponentLicenseResponse.component:type_name -> scanoss.api.licenses.v2.ComponentLicenseInfo
	14, // 1: scanoss.api.licenses.v2.ComponentLicenseResponse.status:type_name -> scanoss.api.common.v2.StatusResponse
	10, // 2: scanoss.api.licenses.v2.ComponentsLicenseResponse.components:type_name -> scanoss.api.licenses.v2.ComponentLicenseInfo
	14, // 3: scanoss.api.licenses.v2.ComponentsLicenseResponse.status:type_name -> scanoss.api.common.v2.StatusResponse
	8,  // 4: scanoss.api.licenses.v2.LicenseDetailsResponse.license:type_name -> scanoss.api.licenses.v2.LicenseDetails
	14, // 5: scanoss.api.licenses.v2.LicenseDetailsResponse.status:type_name -> scanoss.api.common.v2.StatusResponse
	6,  // 6: scanoss.api.licenses.v2.ObligationsResponse.obligations:type_name -> scanoss.api.licenses.v2.OSADL
	14, // 7: scanoss.api.licenses.v2.ObligationsResponse.status:type_name -> scanoss.api.common.v2.StatusResponse
	11, // 8: scanoss.api.licenses.v2.SPDX.cross_refs:type_name -> scanoss.api.licenses.v2.SPDX.SPDXCrossRef
	12, // 9: scanoss.api.licenses.v2.SPDX.exceptions:type_name -> scanoss.api.licenses.v2.SPDX.SPDXException
	13, // 10: scanoss.api.licenses.v2.OSADL.use_cases:type_name -> scanoss.api.licenses.v2.OSADL.OSADLUseCase
	0,  // 11: scanoss.api.licenses.v2.LicenseDetails.type:type_name -> scanoss.api.licenses.v2.LicenseType
	5,  // 12: scanoss.api.licenses.v2.LicenseDetails.spdx:type_name -> scanoss.api.licenses.v2.SPDX
	6,  // 13: scanoss.api.licenses.v2.LicenseDetails.osadl:type_name -> scanoss.api.licenses.v2.OSADL
	7,  // 14: scanoss.api.licenses.v2.ComponentLicenseInfo.licenses:type_name -> scanoss.api.licenses.v2.LicenseInfo
	15, // 15: scanoss.api.licenses.v2.License.Echo:input_type -> scanoss.api.common.v2.EchoRequest
	16, // 16: scanoss.api.licenses.v2.License.GetComponentLicenses:input_type -> scanoss.api.common.v2.ComponentRequest
	17, // 17: scanoss.api.licenses.v2.License.GetComponentsLicenses:input_type -> scanoss.api.common.v2.ComponentBatchRequest
	9,  // 18: scanoss.api.licenses.v2.License.GetDetails:input_type -> scanoss.api.licenses.v2.LicenseRequest
	9,  // 19: scanoss.api.licenses.v2.License.GetObligations:input_type -> scanoss.api.licenses.v2.LicenseRequest
	18, // 20: scanoss.api.licenses.v2.License.Echo:output_type -> scanoss.api.common.v2.EchoResponse
	1,  // 21: scanoss.api.licenses.v2.License.GetComponentLicenses:output_type -> scanoss.api.licenses.v2.ComponentLicenseResponse
	2,  // 22: scanoss.api.licenses.v2.License.GetComponentsLicenses:output_type -> scanoss.api.licenses.v2.ComponentsLicenseResponse
	3,  // 23: scanoss.api.licenses.v2.License.GetDetails:output_type -> scanoss.api.licenses.v2.LicenseDetailsResponse
	4,  // 24: scanoss.api.licenses.v2.License.GetObligations:output_type -> scanoss.api.licenses.v2.ObligationsResponse
	20, // [20:25] is the sub-list for method output_type
	15, // [15:20] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_scanoss_api_licenses_v2_scanoss_licenses_proto_init() }
func file_scanoss_api_licenses_v2_scanoss_licenses_proto_init() {
	if File_scanoss_api_licenses_v2_scanoss_licenses_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc), len(file_scanoss_api_licenses_v2_scanoss_licenses_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_scanoss_api_licenses_v2_scanoss_licenses_proto_goTypes,
		DependencyIndexes: file_scanoss_api_licenses_v2_scanoss_licenses_proto_depIdxs,
		EnumInfos:         file_scanoss_api_licenses_v2_scanoss_licenses_proto_enumTypes,
		MessageInfos:      file_scanoss_api_licenses_v2_scanoss_licenses_proto_msgTypes,
	}.Build()
	File_scanoss_api_licenses_v2_scanoss_licenses_proto = out.File
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_goTypes = nil
	file_scanoss_api_licenses_v2_scanoss_licenses_proto_depIdxs = nil
}
